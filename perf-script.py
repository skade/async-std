# perf script event handlers, generated by perf script -g python
# Licensed under the terms of the GNU GPL License version 2

# The common_* event handler fields are the most useful fields common to
# all events.  They don't necessarily correspond to the 'common_*' fields
# in the format files.  Those fields not available as handler params can
# be retrieved using Python functions of the form common_*(context).
# See the perf-script-python Documentation for the list of available functions.

import os
import sys
import math

sys.path.append(os.environ['PERF_EXEC_PATH'] + \
        '/scripts/python/Perf-Trace-Util/lib/Perf/Trace')

from perf_trace_context import *
from Core import *
from Util import *

class Machine:
    def __init__(self, machine_id, started_at_nanos):
        self.machine_id = machine_id
        self.started_at_nanos = started_at_nanos
        self.blocked_by = []
        self.tasks = []

    def blocked_at(self, time_nanos):
        (blocking_task, _, _) = self.tasks[-1]
        blocking_task.blocked_at(time_nanos)
        self.blocked_by.append((blocking_task, time_nanos))

    def task_scheduled(self, task, local, time_nanos):
        self.tasks.append((task, local, time_nanos))

    def task_handled(self):
        return len(self.tasks)

    def number_of_blockades(self):
        return len(self.blocked_by)

    def task_ids(self):
        for task in self.tasks:
            yield str(task[0].task_id)

    def avg_completion_time(self):
        n_vals = 0
        time_sum = 0
        for task in self.tasks:
            n_vals += 1
            runlength = task[0].runlength()
            time_sum += runlength
        avg_val = math.ceil(avg(time_sum, n_vals))
        return avg_val

class Task:
    def __init__(self, task_id, parent_id):
        self.task_id = task_id
        self.parent_id = parent_id
        self.blockades = []

    def spawned_at(self, time_nanos):
        self.spawned_at = time_nanos

    def scheduled_at(self, time_nanos):
        self.scheduled_at = time_nanos

    def blocked_at(self, time_nanos):
        self.blockades.append(time_nanos)

    def number_of_blockades(self):
        return len(self.blockades)

    def ever_blocked(self):
        return self.number_of_blockades() != 0;

    def completed_at(self, time_nanos):
        self.completed_at = time_nanos

    def runlength(self):
        return self.completed_at - self.spawned_at

class ParentTask:
    def __init__(self, task_id):
        self.task_id = task_id
        self.children = []

    def add_child_task(self, task):
        self.children.append(task)

    def number_of_child_tasks(self):
        return len(self.children)

    def ratio_of_child_tasks_blocked(self):
        num_blocked = 0;
        for child in self.children:
             if child.ever_blocked():
                 num_blocked += 1
        return num_blocked / self.number_of_child_tasks()

def trace_begin():
        print("in trace_begin")
        global seen_machines
        global seen_tasks
        global seen_parent_tasks
        seen_machines = {}
        seen_tasks = {}
        seen_parent_tasks = {}

def trace_end():
        print("in trace_end")
        print("------ REPORT ------")
        print("------ MACHINES  ------")
        print("Number | Machine addr     | Tasks handled | Blockades | Task IDs                       | Avg Completion Time (secs)")

        machine_number = 0
        for (machine_addr, machine) in seen_machines.items():
                machine_number += 1
                print("%-6d | %-16s | %-13d | %-9d | %-30s | %-20s" % \
                      (machine_number, machine_addr, machine.task_handled(), machine.number_of_blockades(),
                       ','.join(machine.task_ids()), nsecs_str(machine.avg_completion_time())[0]))

        print("------ TASKS  ------")

        print("Task id    | Parent id |  | spawned_at           | runlength            | Blockades")
        for (task_id, task) in seen_tasks.items():
                print("%-10s | %-10s | %-20s | %-20s | %-4d" % \
                      (task_id, task.parent_id, nsecs_str(task.spawned_at)[0], nsecs_str(task.runlength())[0], task.number_of_blockades()))

        print("------ PARENT TASKS  ------")

        print("Task id    | Number of child tasks | Ratio of child tasks blocked")
        for (task_id, task) in seen_parent_tasks.items():
                print("%-10s | %-21s | %-20s " % \
                      (task_id, task.number_of_child_tasks(), task.ratio_of_child_tasks_blocked()))


def raw_syscalls__sys_enter(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm,
        id, args):
                print_header(event_name, common_cpu, common_secs, common_nsecs,
                        common_pid, common_comm)

                print("id=%d, args=%s\n" % \
                (id, args),)

def trace_unhandled(event_name, context, event_fields_dict):
        print(event_name)
        print(context)
        print(' '.join(['%s=%s'%(k,str(v))for k,v in sorted(event_fields_dict.items())]))

def probe_task__async_std_task_completed(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm, common_callchain,
        probe_ip, task_id):

        task = seen_tasks[task_id]
        task.completed_at(common_nsecs)

def probe_task__async_std_machine_scheduled_task(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm, common_callchain,
        probe_ip, machine_addr, task_id, local):
        
        machine = None
        if machine_addr in seen_machines:
                machine = seen_machines[machine_addr]
        else:
                machine = Machine(machine, common_nsecs)
                seen_machines[machine_addr] = machine

        task = seen_tasks[task_id]

        machine.task_scheduled(task, local, common_nsecs)


def probe_task__async_std_machine_blocked(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm, common_callchain,
        probe_ip, machine):

        machine = seen_machines[machine]
        machine.blocked_at(common_nsecs)


def probe_task__async_std_task_spawn(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm, common_callchain,
        probe_ip, task_id, parent_id, name):
        task = Task(task_id, parent_id)
        add_child(task, parent_id)
        task.spawned_at(common_nsecs)
        seen_tasks[task_id] = task

def print_header(event_name, cpu, secs, nsecs, pid, comm):
        print("%-20s %5u %05u.%09u %8u %-20s " % \
        (event_name, cpu, secs, nsecs, pid, comm),)

def add_child(task, parent_id):
        if parent_id in seen_parent_tasks:
                seen_parent_tasks[parent_id].add_child_task(task)
        else:
                parent_task = ParentTask(parent_id)
                parent_task.add_child_task(task)
                seen_parent_tasks[parent_id] = parent_task

