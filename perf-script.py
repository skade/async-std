# perf script event handlers, generated by perf script -g python
# Licensed under the terms of the GNU GPL License version 2

# The common_* event handler fields are the most useful fields common to
# all events.  They don't necessarily correspond to the 'common_*' fields
# in the format files.  Those fields not available as handler params can
# be retrieved using Python functions of the form common_*(context).
# See the perf-script-python Documentation for the list of available functions.

import os
import sys

sys.path.append(os.environ['PERF_EXEC_PATH'] + \
        '/scripts/python/Perf-Trace-Util/lib/Perf/Trace')

from perf_trace_context import *
from Core import *

class Machine:
    def __init__(self, machine_id, started_at_nanos):
        self.machine_id = machine_id
        self.started_at_nanos = started_at_nanos
        self.blocked_by = []
        self.tasks = []

    def blocked_at(self, time_nanos):
        (blocking_task, _, _) = self.tasks[-1]
        blocking_task.blocked_at(time_nanos)
        self.blocked_by.append((blocking_task, time_nanos))

    def task_scheduled(self, task, local, time_nanos):
        self.tasks.append((task, local, time_nanos))

    def task_handled(self):
        return len(self.tasks)

    def number_of_blockades(self):
        return len(self.blocked_by)

class Task:
    def __init__(self, task_id, parent_id):
        self.task_id = task_id
        self.parent_id = parent_id
        self.blockades = []

    def spawned_at(self, time_nanos):
        self.spawned_at = time_nanos

    def scheduled_at(self, time_nanos):
        self.scheduled_at = time_nanos

    def blocked_at(self, time_nanos):
        self.blockades.append(time_nanos)

    def completed_at(self, time_nanos):
        self.completed_at = time_nanos

class ParentTask:
    def __init__(self, task_id):
        self.task_id = task_id
        self.children = []

    def add_child_task(self, task):
        self.children.append(task)


def trace_begin():
        print("in trace_begin")
        global seen_machines
        global seen_tasks
        global seen_parent_tasks
        seen_machines = {}
        seen_tasks = {}
        seen_parent_tasks = {}

def trace_end():
        print("in trace_end")
        print("------ REPORT ------")
        print("Machine addr     | Tasks handled | Blockades | Task IDs")

        for (machine_addr, machine) in seen_machines.items():
                print("%-16s | %-13d | %-10d " % \
                      (machine_addr, machine.task_handled(), machine.number_of_blockades()))


def raw_syscalls__sys_enter(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm,
        id, args):
                print_header(event_name, common_cpu, common_secs, common_nsecs,
                        common_pid, common_comm)

                print("id=%d, args=%s\n" % \
                (id, args),)

def trace_unhandled(event_name, context, event_fields_dict):
        print(event_name)
        print(context)
        print(' '.join(['%s=%s'%(k,str(v))for k,v in sorted(event_fields_dict.items())]))

def probe_task__async_std_task_completed(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm, common_callchain,
        probe_ip, task_id):

        task = seen_tasks[task_id]
        task.completed_at(common_nsecs)

def probe_task__async_std_machine_scheduled_task(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm, common_callchain,
        probe_ip, machine_addr, local, task_id):
        
        machine = None
        if machine_addr in seen_machines:
                machine = seen_machines[machine_addr]
        else:
                machine = Machine(machine, common_nsecs)
                seen_machines[machine_addr] = machine

        task = seen_tasks[task_id]
        machine.task_scheduled(task, local, common_nsecs)


def probe_task__async_std_machine_blocked(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm, common_callchain,
        probe_ip, machine):

        machine = seen_machines[machine]
        machine.blocked_at(common_nsecs)


def probe_task__async_std_task_spawn(event_name, context, common_cpu,
        common_secs, common_nsecs, common_pid, common_comm, common_callchain,
        probe_ip, task_id, parent_id, name):

        task = Task(task_id, parent_id)
        add_child(task, parent_id)
        task.spawned_at(common_nsecs)
        seen_tasks[task_id] = task

def print_header(event_name, cpu, secs, nsecs, pid, comm):
        print("%-20s %5u %05u.%09u %8u %-20s " % \
        (event_name, cpu, secs, nsecs, pid, comm),)

def add_child(task, parent_id):
        if parent_id in seen_parent_tasks:
                seen_parent_tasks[parent_id].add_child_task(task)
        else:
                parent_task = ParentTask(parent_id)
                parent_task.add_child_task(task)
                seen_parent_tasks[parent_id] = parent_task

